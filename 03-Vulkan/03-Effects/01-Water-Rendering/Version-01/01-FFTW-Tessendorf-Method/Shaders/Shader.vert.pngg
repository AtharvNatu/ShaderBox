#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(location = 0) in vec3 inPos;   // mesh position
layout(location = 1) in vec2 inUV;    // UV coordinates

layout(binding = 0) uniform VertexUBO 
{
    mat4 modelMatrix;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    vec4 waveParameters; // x=HeightAmp, y=Choppy, z=Scale, w=Time
} ubo;

layout(binding = 1) uniform sampler2D dudvMap;
layout(binding = 2) uniform sampler2D normalMap;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec3 fragNormal;
layout(location = 2) out vec3 fragPos;

void main()
{
    float height = ubo.waveParameters.x;
    float choppy = ubo.waveParameters.y;
    float scale  = ubo.waveParameters.z;
    float time   = ubo.waveParameters.w;

    // Scale + animate UVs for displacement
    vec2 uvScaled   = inUV * scale;
    vec2 dudvShift  = vec2(time * 0.05, time * 0.03);
    vec2 uvTime     = uvScaled + dudvShift;

    // Sample dudv (DuDv) map and compute vertical displacement
    vec3 dudv       = texture(dudvMap, uvTime).rgb;

    // float dispHeight= (dudv.r - 0.5) * height;
    // vec3 displacedPos = inPos + vec3(0.0, dispHeight, 0.0);

    float dispY     = (dudv.r - 0.5) * heightAmp;
    float dispX     = (dudv.g - 0.5) * choppy * 0.5; // horizontal shift
    float dispZ     = (dudv.b - 0.5) * choppy * 0.5;

    vec3 displaced  = vPosition + vec3(dispX, dispY, dispZ);

    // Final clip-space position
    gl_Position = ubo.projectionMatrix *
                  ubo.viewMatrix *
                  ubo.modelMatrix *
                  vec4(displacedPos, 1.0);

    // Animated UVs for normal map sampling
    vec2 nUV = uvScaled + vec2(time * 0.02, time * 0.04);
    vec3 n   = texture(normalMap, nUV).rgb;

    // Transform [0,1] â†’ [-1,1]
    fragNormal = normalize(n * 2.0 - 1.0);

    // Pass world-space position and UV to fragment shader
    fragPos = vec3(ubo.modelMatrix * vec4(displacedPos, 1.0));
    fragUV  = inUV;
}
